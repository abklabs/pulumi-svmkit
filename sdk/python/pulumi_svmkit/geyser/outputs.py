# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'Config',
    'GeyserPlugin',
    'GrpcConfigFilterLimits',
    'GrpcConfigFilterLimitsAccounts',
    'GrpcConfigFilterLimitsBlocks',
    'GrpcConfigFilterLimitsBlocksMeta',
    'GrpcConfigFilterLimitsEntries',
    'GrpcConfigFilterLimitsSlots',
    'GrpcConfigFilterLimitsTransactions',
    'GrpcConfigGrpc',
    'GrpcConfigGrpcCompression',
    'GrpcConfigGrpcServerTLS',
    'GrpcConfigLog',
    'GrpcConfigPrometheus',
    'GrpcConfigTokio',
    'YellowstoneGRPC',
]

@pulumi.output_type
class Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "debugClientsHttp":
            suggest = "debug_clients_http"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grpc: 'outputs.GrpcConfigGrpc',
                 debug_clients_http: Optional[builtins.bool] = None,
                 log: Optional['outputs.GrpcConfigLog'] = None,
                 prometheus: Optional['outputs.GrpcConfigPrometheus'] = None,
                 tokio: Optional['outputs.GrpcConfigTokio'] = None):
        pulumi.set(__self__, "grpc", grpc)
        if debug_clients_http is not None:
            pulumi.set(__self__, "debug_clients_http", debug_clients_http)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if tokio is not None:
            pulumi.set(__self__, "tokio", tokio)

    @property
    @pulumi.getter
    def grpc(self) -> 'outputs.GrpcConfigGrpc':
        return pulumi.get(self, "grpc")

    @property
    @pulumi.getter(name="debugClientsHttp")
    def debug_clients_http(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "debug_clients_http")

    @property
    @pulumi.getter
    def log(self) -> Optional['outputs.GrpcConfigLog']:
        return pulumi.get(self, "log")

    @property
    @pulumi.getter
    def prometheus(self) -> Optional['outputs.GrpcConfigPrometheus']:
        return pulumi.get(self, "prometheus")

    @property
    @pulumi.getter
    def tokio(self) -> Optional['outputs.GrpcConfigTokio']:
        return pulumi.get(self, "tokio")


@pulumi.output_type
class GeyserPlugin(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "genericPluginConfig":
            suggest = "generic_plugin_config"
        elif key == "yellowstoneGRPC":
            suggest = "yellowstone_grpc"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GeyserPlugin. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GeyserPlugin.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GeyserPlugin.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generic_plugin_config: Optional[builtins.str] = None,
                 yellowstone_grpc: Optional['outputs.YellowstoneGRPC'] = None):
        if generic_plugin_config is not None:
            pulumi.set(__self__, "generic_plugin_config", generic_plugin_config)
        if yellowstone_grpc is not None:
            pulumi.set(__self__, "yellowstone_grpc", yellowstone_grpc)

    @property
    @pulumi.getter(name="genericPluginConfig")
    def generic_plugin_config(self) -> Optional[builtins.str]:
        return pulumi.get(self, "generic_plugin_config")

    @property
    @pulumi.getter(name="yellowstoneGRPC")
    def yellowstone_grpc(self) -> Optional['outputs.YellowstoneGRPC']:
        return pulumi.get(self, "yellowstone_grpc")


@pulumi.output_type
class GrpcConfigFilterLimits(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "blocksMeta":
            suggest = "blocks_meta"
        elif key == "transactionsStatus":
            suggest = "transactions_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrpcConfigFilterLimits. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrpcConfigFilterLimits.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrpcConfigFilterLimits.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 accounts: Optional['outputs.GrpcConfigFilterLimitsAccounts'] = None,
                 blocks: Optional['outputs.GrpcConfigFilterLimitsBlocks'] = None,
                 blocks_meta: Optional['outputs.GrpcConfigFilterLimitsBlocksMeta'] = None,
                 entries: Optional['outputs.GrpcConfigFilterLimitsEntries'] = None,
                 slots: Optional['outputs.GrpcConfigFilterLimitsSlots'] = None,
                 transactions: Optional['outputs.GrpcConfigFilterLimitsTransactions'] = None,
                 transactions_status: Optional['outputs.GrpcConfigFilterLimitsTransactions'] = None):
        if accounts is not None:
            pulumi.set(__self__, "accounts", accounts)
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)
        if blocks_meta is not None:
            pulumi.set(__self__, "blocks_meta", blocks_meta)
        if entries is not None:
            pulumi.set(__self__, "entries", entries)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)
        if transactions is not None:
            pulumi.set(__self__, "transactions", transactions)
        if transactions_status is not None:
            pulumi.set(__self__, "transactions_status", transactions_status)

    @property
    @pulumi.getter
    def accounts(self) -> Optional['outputs.GrpcConfigFilterLimitsAccounts']:
        return pulumi.get(self, "accounts")

    @property
    @pulumi.getter
    def blocks(self) -> Optional['outputs.GrpcConfigFilterLimitsBlocks']:
        return pulumi.get(self, "blocks")

    @property
    @pulumi.getter(name="blocksMeta")
    def blocks_meta(self) -> Optional['outputs.GrpcConfigFilterLimitsBlocksMeta']:
        return pulumi.get(self, "blocks_meta")

    @property
    @pulumi.getter
    def entries(self) -> Optional['outputs.GrpcConfigFilterLimitsEntries']:
        return pulumi.get(self, "entries")

    @property
    @pulumi.getter
    def slots(self) -> Optional['outputs.GrpcConfigFilterLimitsSlots']:
        return pulumi.get(self, "slots")

    @property
    @pulumi.getter
    def transactions(self) -> Optional['outputs.GrpcConfigFilterLimitsTransactions']:
        return pulumi.get(self, "transactions")

    @property
    @pulumi.getter(name="transactionsStatus")
    def transactions_status(self) -> Optional['outputs.GrpcConfigFilterLimitsTransactions']:
        return pulumi.get(self, "transactions_status")


@pulumi.output_type
class GrpcConfigFilterLimitsAccounts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountMax":
            suggest = "account_max"
        elif key == "accountReject":
            suggest = "account_reject"
        elif key == "dataSliceMax":
            suggest = "data_slice_max"
        elif key == "ownerMax":
            suggest = "owner_max"
        elif key == "ownerReject":
            suggest = "owner_reject"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrpcConfigFilterLimitsAccounts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrpcConfigFilterLimitsAccounts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrpcConfigFilterLimitsAccounts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_max: Optional[builtins.int] = None,
                 account_reject: Optional[Sequence[builtins.str]] = None,
                 any: Optional[builtins.bool] = None,
                 data_slice_max: Optional[builtins.int] = None,
                 max: Optional[builtins.int] = None,
                 owner_max: Optional[builtins.int] = None,
                 owner_reject: Optional[Sequence[builtins.str]] = None):
        if account_max is not None:
            pulumi.set(__self__, "account_max", account_max)
        if account_reject is not None:
            pulumi.set(__self__, "account_reject", account_reject)
        if any is not None:
            pulumi.set(__self__, "any", any)
        if data_slice_max is not None:
            pulumi.set(__self__, "data_slice_max", data_slice_max)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if owner_max is not None:
            pulumi.set(__self__, "owner_max", owner_max)
        if owner_reject is not None:
            pulumi.set(__self__, "owner_reject", owner_reject)

    @property
    @pulumi.getter(name="accountMax")
    def account_max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "account_max")

    @property
    @pulumi.getter(name="accountReject")
    def account_reject(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "account_reject")

    @property
    @pulumi.getter
    def any(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "any")

    @property
    @pulumi.getter(name="dataSliceMax")
    def data_slice_max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "data_slice_max")

    @property
    @pulumi.getter
    def max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter(name="ownerMax")
    def owner_max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "owner_max")

    @property
    @pulumi.getter(name="ownerReject")
    def owner_reject(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "owner_reject")


@pulumi.output_type
class GrpcConfigFilterLimitsBlocks(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountIncludeAny":
            suggest = "account_include_any"
        elif key == "accountIncludeMax":
            suggest = "account_include_max"
        elif key == "accountIncludeReject":
            suggest = "account_include_reject"
        elif key == "includeAccounts":
            suggest = "include_accounts"
        elif key == "includeEntries":
            suggest = "include_entries"
        elif key == "includeTransactions":
            suggest = "include_transactions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrpcConfigFilterLimitsBlocks. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrpcConfigFilterLimitsBlocks.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrpcConfigFilterLimitsBlocks.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_include_any: Optional[builtins.bool] = None,
                 account_include_max: Optional[builtins.int] = None,
                 account_include_reject: Optional[Sequence[builtins.str]] = None,
                 include_accounts: Optional[builtins.bool] = None,
                 include_entries: Optional[builtins.bool] = None,
                 include_transactions: Optional[builtins.bool] = None,
                 max: Optional[builtins.int] = None):
        if account_include_any is not None:
            pulumi.set(__self__, "account_include_any", account_include_any)
        if account_include_max is not None:
            pulumi.set(__self__, "account_include_max", account_include_max)
        if account_include_reject is not None:
            pulumi.set(__self__, "account_include_reject", account_include_reject)
        if include_accounts is not None:
            pulumi.set(__self__, "include_accounts", include_accounts)
        if include_entries is not None:
            pulumi.set(__self__, "include_entries", include_entries)
        if include_transactions is not None:
            pulumi.set(__self__, "include_transactions", include_transactions)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter(name="accountIncludeAny")
    def account_include_any(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "account_include_any")

    @property
    @pulumi.getter(name="accountIncludeMax")
    def account_include_max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "account_include_max")

    @property
    @pulumi.getter(name="accountIncludeReject")
    def account_include_reject(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "account_include_reject")

    @property
    @pulumi.getter(name="includeAccounts")
    def include_accounts(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "include_accounts")

    @property
    @pulumi.getter(name="includeEntries")
    def include_entries(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "include_entries")

    @property
    @pulumi.getter(name="includeTransactions")
    def include_transactions(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "include_transactions")

    @property
    @pulumi.getter
    def max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max")


@pulumi.output_type
class GrpcConfigFilterLimitsBlocksMeta(dict):
    def __init__(__self__, *,
                 max: Optional[builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter
    def max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max")


@pulumi.output_type
class GrpcConfigFilterLimitsEntries(dict):
    def __init__(__self__, *,
                 max: Optional[builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter
    def max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max")


@pulumi.output_type
class GrpcConfigFilterLimitsSlots(dict):
    def __init__(__self__, *,
                 max: Optional[builtins.int] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter
    def max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max")


@pulumi.output_type
class GrpcConfigFilterLimitsTransactions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accountExcludeMax":
            suggest = "account_exclude_max"
        elif key == "accountIncludeMax":
            suggest = "account_include_max"
        elif key == "accountIncludeReject":
            suggest = "account_include_reject"
        elif key == "accountRequiredMax":
            suggest = "account_required_max"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrpcConfigFilterLimitsTransactions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrpcConfigFilterLimitsTransactions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrpcConfigFilterLimitsTransactions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 account_exclude_max: Optional[builtins.int] = None,
                 account_include_max: Optional[builtins.int] = None,
                 account_include_reject: Optional[Sequence[builtins.str]] = None,
                 account_required_max: Optional[builtins.int] = None,
                 any: Optional[builtins.bool] = None,
                 max: Optional[builtins.int] = None):
        if account_exclude_max is not None:
            pulumi.set(__self__, "account_exclude_max", account_exclude_max)
        if account_include_max is not None:
            pulumi.set(__self__, "account_include_max", account_include_max)
        if account_include_reject is not None:
            pulumi.set(__self__, "account_include_reject", account_include_reject)
        if account_required_max is not None:
            pulumi.set(__self__, "account_required_max", account_required_max)
        if any is not None:
            pulumi.set(__self__, "any", any)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter(name="accountExcludeMax")
    def account_exclude_max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "account_exclude_max")

    @property
    @pulumi.getter(name="accountIncludeMax")
    def account_include_max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "account_include_max")

    @property
    @pulumi.getter(name="accountIncludeReject")
    def account_include_reject(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "account_include_reject")

    @property
    @pulumi.getter(name="accountRequiredMax")
    def account_required_max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "account_required_max")

    @property
    @pulumi.getter
    def any(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "any")

    @property
    @pulumi.getter
    def max(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max")


@pulumi.output_type
class GrpcConfigGrpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelCapacity":
            suggest = "channel_capacity"
        elif key == "filterLimits":
            suggest = "filter_limits"
        elif key == "filterNameSizeLimit":
            suggest = "filter_name_size_limit"
        elif key == "filterNamesCleanupInterval":
            suggest = "filter_names_cleanup_interval"
        elif key == "filterNamesSizeLimit":
            suggest = "filter_names_size_limit"
        elif key == "maxDecodingMessageSize":
            suggest = "max_decoding_message_size"
        elif key == "replayStoredSlots":
            suggest = "replay_stored_slots"
        elif key == "serverHttp2AdaptiveWindow":
            suggest = "server_http2_adaptive_window"
        elif key == "serverHttp2KeepaliveInterval":
            suggest = "server_http2_keepalive_interval"
        elif key == "serverHttp2KeepaliveTimeout":
            suggest = "server_http2_keepalive_timeout"
        elif key == "serverInitialConnectionWindowSize":
            suggest = "server_initial_connection_window_size"
        elif key == "serverInitialStreamWindowSize":
            suggest = "server_initial_stream_window_size"
        elif key == "snapshotClientChannelCapacity":
            suggest = "snapshot_client_channel_capacity"
        elif key == "snapshotPluginChannelCapacity":
            suggest = "snapshot_plugin_channel_capacity"
        elif key == "tlsConfig":
            suggest = "tls_config"
        elif key == "unaryConcurrencyLimit":
            suggest = "unary_concurrency_limit"
        elif key == "unaryDisabled":
            suggest = "unary_disabled"
        elif key == "xToken":
            suggest = "x_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrpcConfigGrpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrpcConfigGrpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrpcConfigGrpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: builtins.str,
                 channel_capacity: Optional[builtins.int] = None,
                 compression: Optional['outputs.GrpcConfigGrpcCompression'] = None,
                 filter_limits: Optional['outputs.GrpcConfigFilterLimits'] = None,
                 filter_name_size_limit: Optional[builtins.int] = None,
                 filter_names_cleanup_interval: Optional[builtins.str] = None,
                 filter_names_size_limit: Optional[builtins.int] = None,
                 max_decoding_message_size: Optional[builtins.int] = None,
                 replay_stored_slots: Optional[builtins.int] = None,
                 server_http2_adaptive_window: Optional[builtins.bool] = None,
                 server_http2_keepalive_interval: Optional[builtins.str] = None,
                 server_http2_keepalive_timeout: Optional[builtins.str] = None,
                 server_initial_connection_window_size: Optional[builtins.int] = None,
                 server_initial_stream_window_size: Optional[builtins.int] = None,
                 snapshot_client_channel_capacity: Optional[builtins.int] = None,
                 snapshot_plugin_channel_capacity: Optional[builtins.int] = None,
                 tls_config: Optional['outputs.GrpcConfigGrpcServerTLS'] = None,
                 unary_concurrency_limit: Optional[builtins.int] = None,
                 unary_disabled: Optional[builtins.bool] = None,
                 x_token: Optional[builtins.str] = None):
        pulumi.set(__self__, "address", address)
        if channel_capacity is not None:
            pulumi.set(__self__, "channel_capacity", channel_capacity)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if filter_limits is not None:
            pulumi.set(__self__, "filter_limits", filter_limits)
        if filter_name_size_limit is not None:
            pulumi.set(__self__, "filter_name_size_limit", filter_name_size_limit)
        if filter_names_cleanup_interval is not None:
            pulumi.set(__self__, "filter_names_cleanup_interval", filter_names_cleanup_interval)
        if filter_names_size_limit is not None:
            pulumi.set(__self__, "filter_names_size_limit", filter_names_size_limit)
        if max_decoding_message_size is not None:
            pulumi.set(__self__, "max_decoding_message_size", max_decoding_message_size)
        if replay_stored_slots is not None:
            pulumi.set(__self__, "replay_stored_slots", replay_stored_slots)
        if server_http2_adaptive_window is not None:
            pulumi.set(__self__, "server_http2_adaptive_window", server_http2_adaptive_window)
        if server_http2_keepalive_interval is not None:
            pulumi.set(__self__, "server_http2_keepalive_interval", server_http2_keepalive_interval)
        if server_http2_keepalive_timeout is not None:
            pulumi.set(__self__, "server_http2_keepalive_timeout", server_http2_keepalive_timeout)
        if server_initial_connection_window_size is not None:
            pulumi.set(__self__, "server_initial_connection_window_size", server_initial_connection_window_size)
        if server_initial_stream_window_size is not None:
            pulumi.set(__self__, "server_initial_stream_window_size", server_initial_stream_window_size)
        if snapshot_client_channel_capacity is not None:
            pulumi.set(__self__, "snapshot_client_channel_capacity", snapshot_client_channel_capacity)
        if snapshot_plugin_channel_capacity is not None:
            pulumi.set(__self__, "snapshot_plugin_channel_capacity", snapshot_plugin_channel_capacity)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if unary_concurrency_limit is not None:
            pulumi.set(__self__, "unary_concurrency_limit", unary_concurrency_limit)
        if unary_disabled is not None:
            pulumi.set(__self__, "unary_disabled", unary_disabled)
        if x_token is not None:
            pulumi.set(__self__, "x_token", x_token)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="channelCapacity")
    def channel_capacity(self) -> Optional[builtins.int]:
        return pulumi.get(self, "channel_capacity")

    @property
    @pulumi.getter
    def compression(self) -> Optional['outputs.GrpcConfigGrpcCompression']:
        return pulumi.get(self, "compression")

    @property
    @pulumi.getter(name="filterLimits")
    def filter_limits(self) -> Optional['outputs.GrpcConfigFilterLimits']:
        return pulumi.get(self, "filter_limits")

    @property
    @pulumi.getter(name="filterNameSizeLimit")
    def filter_name_size_limit(self) -> Optional[builtins.int]:
        return pulumi.get(self, "filter_name_size_limit")

    @property
    @pulumi.getter(name="filterNamesCleanupInterval")
    def filter_names_cleanup_interval(self) -> Optional[builtins.str]:
        return pulumi.get(self, "filter_names_cleanup_interval")

    @property
    @pulumi.getter(name="filterNamesSizeLimit")
    def filter_names_size_limit(self) -> Optional[builtins.int]:
        return pulumi.get(self, "filter_names_size_limit")

    @property
    @pulumi.getter(name="maxDecodingMessageSize")
    def max_decoding_message_size(self) -> Optional[builtins.int]:
        return pulumi.get(self, "max_decoding_message_size")

    @property
    @pulumi.getter(name="replayStoredSlots")
    def replay_stored_slots(self) -> Optional[builtins.int]:
        return pulumi.get(self, "replay_stored_slots")

    @property
    @pulumi.getter(name="serverHttp2AdaptiveWindow")
    def server_http2_adaptive_window(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "server_http2_adaptive_window")

    @property
    @pulumi.getter(name="serverHttp2KeepaliveInterval")
    def server_http2_keepalive_interval(self) -> Optional[builtins.str]:
        return pulumi.get(self, "server_http2_keepalive_interval")

    @property
    @pulumi.getter(name="serverHttp2KeepaliveTimeout")
    def server_http2_keepalive_timeout(self) -> Optional[builtins.str]:
        return pulumi.get(self, "server_http2_keepalive_timeout")

    @property
    @pulumi.getter(name="serverInitialConnectionWindowSize")
    def server_initial_connection_window_size(self) -> Optional[builtins.int]:
        return pulumi.get(self, "server_initial_connection_window_size")

    @property
    @pulumi.getter(name="serverInitialStreamWindowSize")
    def server_initial_stream_window_size(self) -> Optional[builtins.int]:
        return pulumi.get(self, "server_initial_stream_window_size")

    @property
    @pulumi.getter(name="snapshotClientChannelCapacity")
    def snapshot_client_channel_capacity(self) -> Optional[builtins.int]:
        return pulumi.get(self, "snapshot_client_channel_capacity")

    @property
    @pulumi.getter(name="snapshotPluginChannelCapacity")
    def snapshot_plugin_channel_capacity(self) -> Optional[builtins.int]:
        return pulumi.get(self, "snapshot_plugin_channel_capacity")

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional['outputs.GrpcConfigGrpcServerTLS']:
        return pulumi.get(self, "tls_config")

    @property
    @pulumi.getter(name="unaryConcurrencyLimit")
    def unary_concurrency_limit(self) -> Optional[builtins.int]:
        return pulumi.get(self, "unary_concurrency_limit")

    @property
    @pulumi.getter(name="unaryDisabled")
    def unary_disabled(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "unary_disabled")

    @property
    @pulumi.getter(name="xToken")
    def x_token(self) -> Optional[builtins.str]:
        return pulumi.get(self, "x_token")


@pulumi.output_type
class GrpcConfigGrpcCompression(dict):
    def __init__(__self__, *,
                 accept: Optional[Sequence[builtins.str]] = None,
                 send: Optional[Sequence[builtins.str]] = None):
        if accept is not None:
            pulumi.set(__self__, "accept", accept)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def accept(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "accept")

    @property
    @pulumi.getter
    def send(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "send")


@pulumi.output_type
class GrpcConfigGrpcServerTLS(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certPath":
            suggest = "cert_path"
        elif key == "keyPath":
            suggest = "key_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrpcConfigGrpcServerTLS. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrpcConfigGrpcServerTLS.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrpcConfigGrpcServerTLS.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_path: builtins.str,
                 key_path: builtins.str):
        pulumi.set(__self__, "cert_path", cert_path)
        pulumi.set(__self__, "key_path", key_path)

    @property
    @pulumi.getter(name="certPath")
    def cert_path(self) -> builtins.str:
        return pulumi.get(self, "cert_path")

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> builtins.str:
        return pulumi.get(self, "key_path")


@pulumi.output_type
class GrpcConfigLog(dict):
    def __init__(__self__, *,
                 level: Optional[builtins.str] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def level(self) -> Optional[builtins.str]:
        return pulumi.get(self, "level")


@pulumi.output_type
class GrpcConfigPrometheus(dict):
    def __init__(__self__, *,
                 address: builtins.str):
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> builtins.str:
        return pulumi.get(self, "address")


@pulumi.output_type
class GrpcConfigTokio(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workerThreads":
            suggest = "worker_threads"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GrpcConfigTokio. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GrpcConfigTokio.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GrpcConfigTokio.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 affinity: Optional[Sequence[builtins.int]] = None,
                 worker_threads: Optional[builtins.int] = None):
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if worker_threads is not None:
            pulumi.set(__self__, "worker_threads", worker_threads)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[Sequence[builtins.int]]:
        return pulumi.get(self, "affinity")

    @property
    @pulumi.getter(name="workerThreads")
    def worker_threads(self) -> Optional[builtins.int]:
        return pulumi.get(self, "worker_threads")


@pulumi.output_type
class YellowstoneGRPC(dict):
    def __init__(__self__, *,
                 version: builtins.str,
                 config: Optional['outputs.Config'] = None,
                 json: Optional[builtins.str] = None):
        pulumi.set(__self__, "version", version)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if json is not None:
            pulumi.set(__self__, "json", json)

    @property
    @pulumi.getter
    def version(self) -> builtins.str:
        return pulumi.get(self, "version")

    @property
    @pulumi.getter
    def config(self) -> Optional['outputs.Config']:
        return pulumi.get(self, "config")

    @property
    @pulumi.getter
    def json(self) -> Optional[builtins.str]:
        return pulumi.get(self, "json")


