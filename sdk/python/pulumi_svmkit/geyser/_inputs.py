# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConfigArgs',
    'ConfigArgsDict',
    'GeyserPluginArgs',
    'GeyserPluginArgsDict',
    'GrpcConfigFilterLimitsAccountsArgs',
    'GrpcConfigFilterLimitsAccountsArgsDict',
    'GrpcConfigFilterLimitsBlocksMetaArgs',
    'GrpcConfigFilterLimitsBlocksMetaArgsDict',
    'GrpcConfigFilterLimitsBlocksArgs',
    'GrpcConfigFilterLimitsBlocksArgsDict',
    'GrpcConfigFilterLimitsEntriesArgs',
    'GrpcConfigFilterLimitsEntriesArgsDict',
    'GrpcConfigFilterLimitsSlotsArgs',
    'GrpcConfigFilterLimitsSlotsArgsDict',
    'GrpcConfigFilterLimitsTransactionsArgs',
    'GrpcConfigFilterLimitsTransactionsArgsDict',
    'GrpcConfigFilterLimitsArgs',
    'GrpcConfigFilterLimitsArgsDict',
    'GrpcConfigGrpcCompressionArgs',
    'GrpcConfigGrpcCompressionArgsDict',
    'GrpcConfigGrpcServerTLSArgs',
    'GrpcConfigGrpcServerTLSArgsDict',
    'GrpcConfigGrpcArgs',
    'GrpcConfigGrpcArgsDict',
    'GrpcConfigLogArgs',
    'GrpcConfigLogArgsDict',
    'GrpcConfigPrometheusArgs',
    'GrpcConfigPrometheusArgsDict',
    'GrpcConfigTokioArgs',
    'GrpcConfigTokioArgsDict',
    'YellowstoneGRPCArgs',
    'YellowstoneGRPCArgsDict',
]

MYPY = False

if not MYPY:
    class ConfigArgsDict(TypedDict):
        grpc: pulumi.Input['GrpcConfigGrpcArgsDict']
        debug_clients_http: NotRequired[pulumi.Input[builtins.bool]]
        log: NotRequired[pulumi.Input['GrpcConfigLogArgsDict']]
        prometheus: NotRequired[pulumi.Input['GrpcConfigPrometheusArgsDict']]
        tokio: NotRequired[pulumi.Input['GrpcConfigTokioArgsDict']]
elif False:
    ConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConfigArgs:
    def __init__(__self__, *,
                 grpc: pulumi.Input['GrpcConfigGrpcArgs'],
                 debug_clients_http: Optional[pulumi.Input[builtins.bool]] = None,
                 log: Optional[pulumi.Input['GrpcConfigLogArgs']] = None,
                 prometheus: Optional[pulumi.Input['GrpcConfigPrometheusArgs']] = None,
                 tokio: Optional[pulumi.Input['GrpcConfigTokioArgs']] = None):
        pulumi.set(__self__, "grpc", grpc)
        if debug_clients_http is not None:
            pulumi.set(__self__, "debug_clients_http", debug_clients_http)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if prometheus is not None:
            pulumi.set(__self__, "prometheus", prometheus)
        if tokio is not None:
            pulumi.set(__self__, "tokio", tokio)

    @property
    @pulumi.getter
    def grpc(self) -> pulumi.Input['GrpcConfigGrpcArgs']:
        return pulumi.get(self, "grpc")

    @grpc.setter
    def grpc(self, value: pulumi.Input['GrpcConfigGrpcArgs']):
        pulumi.set(self, "grpc", value)

    @property
    @pulumi.getter(name="debugClientsHttp")
    def debug_clients_http(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "debug_clients_http")

    @debug_clients_http.setter
    def debug_clients_http(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "debug_clients_http", value)

    @property
    @pulumi.getter
    def log(self) -> Optional[pulumi.Input['GrpcConfigLogArgs']]:
        return pulumi.get(self, "log")

    @log.setter
    def log(self, value: Optional[pulumi.Input['GrpcConfigLogArgs']]):
        pulumi.set(self, "log", value)

    @property
    @pulumi.getter
    def prometheus(self) -> Optional[pulumi.Input['GrpcConfigPrometheusArgs']]:
        return pulumi.get(self, "prometheus")

    @prometheus.setter
    def prometheus(self, value: Optional[pulumi.Input['GrpcConfigPrometheusArgs']]):
        pulumi.set(self, "prometheus", value)

    @property
    @pulumi.getter
    def tokio(self) -> Optional[pulumi.Input['GrpcConfigTokioArgs']]:
        return pulumi.get(self, "tokio")

    @tokio.setter
    def tokio(self, value: Optional[pulumi.Input['GrpcConfigTokioArgs']]):
        pulumi.set(self, "tokio", value)


if not MYPY:
    class GeyserPluginArgsDict(TypedDict):
        generic_plugin_config: NotRequired[pulumi.Input[builtins.str]]
        yellowstone_grpc: NotRequired[pulumi.Input['YellowstoneGRPCArgsDict']]
elif False:
    GeyserPluginArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeyserPluginArgs:
    def __init__(__self__, *,
                 generic_plugin_config: Optional[pulumi.Input[builtins.str]] = None,
                 yellowstone_grpc: Optional[pulumi.Input['YellowstoneGRPCArgs']] = None):
        if generic_plugin_config is not None:
            pulumi.set(__self__, "generic_plugin_config", generic_plugin_config)
        if yellowstone_grpc is not None:
            pulumi.set(__self__, "yellowstone_grpc", yellowstone_grpc)

    @property
    @pulumi.getter(name="genericPluginConfig")
    def generic_plugin_config(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "generic_plugin_config")

    @generic_plugin_config.setter
    def generic_plugin_config(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "generic_plugin_config", value)

    @property
    @pulumi.getter(name="yellowstoneGRPC")
    def yellowstone_grpc(self) -> Optional[pulumi.Input['YellowstoneGRPCArgs']]:
        return pulumi.get(self, "yellowstone_grpc")

    @yellowstone_grpc.setter
    def yellowstone_grpc(self, value: Optional[pulumi.Input['YellowstoneGRPCArgs']]):
        pulumi.set(self, "yellowstone_grpc", value)


if not MYPY:
    class GrpcConfigFilterLimitsAccountsArgsDict(TypedDict):
        account_max: NotRequired[pulumi.Input[builtins.int]]
        account_reject: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        any: NotRequired[pulumi.Input[builtins.bool]]
        data_slice_max: NotRequired[pulumi.Input[builtins.int]]
        max: NotRequired[pulumi.Input[builtins.int]]
        owner_max: NotRequired[pulumi.Input[builtins.int]]
        owner_reject: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    GrpcConfigFilterLimitsAccountsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigFilterLimitsAccountsArgs:
    def __init__(__self__, *,
                 account_max: Optional[pulumi.Input[builtins.int]] = None,
                 account_reject: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 any: Optional[pulumi.Input[builtins.bool]] = None,
                 data_slice_max: Optional[pulumi.Input[builtins.int]] = None,
                 max: Optional[pulumi.Input[builtins.int]] = None,
                 owner_max: Optional[pulumi.Input[builtins.int]] = None,
                 owner_reject: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if account_max is not None:
            pulumi.set(__self__, "account_max", account_max)
        if account_reject is not None:
            pulumi.set(__self__, "account_reject", account_reject)
        if any is not None:
            pulumi.set(__self__, "any", any)
        if data_slice_max is not None:
            pulumi.set(__self__, "data_slice_max", data_slice_max)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if owner_max is not None:
            pulumi.set(__self__, "owner_max", owner_max)
        if owner_reject is not None:
            pulumi.set(__self__, "owner_reject", owner_reject)

    @property
    @pulumi.getter(name="accountMax")
    def account_max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "account_max")

    @account_max.setter
    def account_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "account_max", value)

    @property
    @pulumi.getter(name="accountReject")
    def account_reject(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "account_reject")

    @account_reject.setter
    def account_reject(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "account_reject", value)

    @property
    @pulumi.getter
    def any(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "any", value)

    @property
    @pulumi.getter(name="dataSliceMax")
    def data_slice_max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "data_slice_max")

    @data_slice_max.setter
    def data_slice_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "data_slice_max", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter(name="ownerMax")
    def owner_max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "owner_max")

    @owner_max.setter
    def owner_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "owner_max", value)

    @property
    @pulumi.getter(name="ownerReject")
    def owner_reject(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "owner_reject")

    @owner_reject.setter
    def owner_reject(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "owner_reject", value)


if not MYPY:
    class GrpcConfigFilterLimitsBlocksMetaArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[builtins.int]]
elif False:
    GrpcConfigFilterLimitsBlocksMetaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigFilterLimitsBlocksMetaArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[builtins.int]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class GrpcConfigFilterLimitsBlocksArgsDict(TypedDict):
        account_include_any: NotRequired[pulumi.Input[builtins.bool]]
        account_include_max: NotRequired[pulumi.Input[builtins.int]]
        account_include_reject: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        include_accounts: NotRequired[pulumi.Input[builtins.bool]]
        include_entries: NotRequired[pulumi.Input[builtins.bool]]
        include_transactions: NotRequired[pulumi.Input[builtins.bool]]
        max: NotRequired[pulumi.Input[builtins.int]]
elif False:
    GrpcConfigFilterLimitsBlocksArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigFilterLimitsBlocksArgs:
    def __init__(__self__, *,
                 account_include_any: Optional[pulumi.Input[builtins.bool]] = None,
                 account_include_max: Optional[pulumi.Input[builtins.int]] = None,
                 account_include_reject: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 include_accounts: Optional[pulumi.Input[builtins.bool]] = None,
                 include_entries: Optional[pulumi.Input[builtins.bool]] = None,
                 include_transactions: Optional[pulumi.Input[builtins.bool]] = None,
                 max: Optional[pulumi.Input[builtins.int]] = None):
        if account_include_any is not None:
            pulumi.set(__self__, "account_include_any", account_include_any)
        if account_include_max is not None:
            pulumi.set(__self__, "account_include_max", account_include_max)
        if account_include_reject is not None:
            pulumi.set(__self__, "account_include_reject", account_include_reject)
        if include_accounts is not None:
            pulumi.set(__self__, "include_accounts", include_accounts)
        if include_entries is not None:
            pulumi.set(__self__, "include_entries", include_entries)
        if include_transactions is not None:
            pulumi.set(__self__, "include_transactions", include_transactions)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter(name="accountIncludeAny")
    def account_include_any(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "account_include_any")

    @account_include_any.setter
    def account_include_any(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "account_include_any", value)

    @property
    @pulumi.getter(name="accountIncludeMax")
    def account_include_max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "account_include_max")

    @account_include_max.setter
    def account_include_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "account_include_max", value)

    @property
    @pulumi.getter(name="accountIncludeReject")
    def account_include_reject(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "account_include_reject")

    @account_include_reject.setter
    def account_include_reject(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "account_include_reject", value)

    @property
    @pulumi.getter(name="includeAccounts")
    def include_accounts(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "include_accounts")

    @include_accounts.setter
    def include_accounts(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_accounts", value)

    @property
    @pulumi.getter(name="includeEntries")
    def include_entries(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "include_entries")

    @include_entries.setter
    def include_entries(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_entries", value)

    @property
    @pulumi.getter(name="includeTransactions")
    def include_transactions(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "include_transactions")

    @include_transactions.setter
    def include_transactions(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "include_transactions", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class GrpcConfigFilterLimitsEntriesArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[builtins.int]]
elif False:
    GrpcConfigFilterLimitsEntriesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigFilterLimitsEntriesArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[builtins.int]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class GrpcConfigFilterLimitsSlotsArgsDict(TypedDict):
        max: NotRequired[pulumi.Input[builtins.int]]
elif False:
    GrpcConfigFilterLimitsSlotsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigFilterLimitsSlotsArgs:
    def __init__(__self__, *,
                 max: Optional[pulumi.Input[builtins.int]] = None):
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class GrpcConfigFilterLimitsTransactionsArgsDict(TypedDict):
        account_exclude_max: NotRequired[pulumi.Input[builtins.int]]
        account_include_max: NotRequired[pulumi.Input[builtins.int]]
        account_include_reject: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        account_required_max: NotRequired[pulumi.Input[builtins.int]]
        any: NotRequired[pulumi.Input[builtins.bool]]
        max: NotRequired[pulumi.Input[builtins.int]]
elif False:
    GrpcConfigFilterLimitsTransactionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigFilterLimitsTransactionsArgs:
    def __init__(__self__, *,
                 account_exclude_max: Optional[pulumi.Input[builtins.int]] = None,
                 account_include_max: Optional[pulumi.Input[builtins.int]] = None,
                 account_include_reject: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 account_required_max: Optional[pulumi.Input[builtins.int]] = None,
                 any: Optional[pulumi.Input[builtins.bool]] = None,
                 max: Optional[pulumi.Input[builtins.int]] = None):
        if account_exclude_max is not None:
            pulumi.set(__self__, "account_exclude_max", account_exclude_max)
        if account_include_max is not None:
            pulumi.set(__self__, "account_include_max", account_include_max)
        if account_include_reject is not None:
            pulumi.set(__self__, "account_include_reject", account_include_reject)
        if account_required_max is not None:
            pulumi.set(__self__, "account_required_max", account_required_max)
        if any is not None:
            pulumi.set(__self__, "any", any)
        if max is not None:
            pulumi.set(__self__, "max", max)

    @property
    @pulumi.getter(name="accountExcludeMax")
    def account_exclude_max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "account_exclude_max")

    @account_exclude_max.setter
    def account_exclude_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "account_exclude_max", value)

    @property
    @pulumi.getter(name="accountIncludeMax")
    def account_include_max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "account_include_max")

    @account_include_max.setter
    def account_include_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "account_include_max", value)

    @property
    @pulumi.getter(name="accountIncludeReject")
    def account_include_reject(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "account_include_reject")

    @account_include_reject.setter
    def account_include_reject(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "account_include_reject", value)

    @property
    @pulumi.getter(name="accountRequiredMax")
    def account_required_max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "account_required_max")

    @account_required_max.setter
    def account_required_max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "account_required_max", value)

    @property
    @pulumi.getter
    def any(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "any")

    @any.setter
    def any(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "any", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max", value)


if not MYPY:
    class GrpcConfigFilterLimitsArgsDict(TypedDict):
        accounts: NotRequired[pulumi.Input['GrpcConfigFilterLimitsAccountsArgsDict']]
        blocks: NotRequired[pulumi.Input['GrpcConfigFilterLimitsBlocksArgsDict']]
        blocks_meta: NotRequired[pulumi.Input['GrpcConfigFilterLimitsBlocksMetaArgsDict']]
        entries: NotRequired[pulumi.Input['GrpcConfigFilterLimitsEntriesArgsDict']]
        slots: NotRequired[pulumi.Input['GrpcConfigFilterLimitsSlotsArgsDict']]
        transactions: NotRequired[pulumi.Input['GrpcConfigFilterLimitsTransactionsArgsDict']]
        transactions_status: NotRequired[pulumi.Input['GrpcConfigFilterLimitsTransactionsArgsDict']]
elif False:
    GrpcConfigFilterLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigFilterLimitsArgs:
    def __init__(__self__, *,
                 accounts: Optional[pulumi.Input['GrpcConfigFilterLimitsAccountsArgs']] = None,
                 blocks: Optional[pulumi.Input['GrpcConfigFilterLimitsBlocksArgs']] = None,
                 blocks_meta: Optional[pulumi.Input['GrpcConfigFilterLimitsBlocksMetaArgs']] = None,
                 entries: Optional[pulumi.Input['GrpcConfigFilterLimitsEntriesArgs']] = None,
                 slots: Optional[pulumi.Input['GrpcConfigFilterLimitsSlotsArgs']] = None,
                 transactions: Optional[pulumi.Input['GrpcConfigFilterLimitsTransactionsArgs']] = None,
                 transactions_status: Optional[pulumi.Input['GrpcConfigFilterLimitsTransactionsArgs']] = None):
        if accounts is not None:
            pulumi.set(__self__, "accounts", accounts)
        if blocks is not None:
            pulumi.set(__self__, "blocks", blocks)
        if blocks_meta is not None:
            pulumi.set(__self__, "blocks_meta", blocks_meta)
        if entries is not None:
            pulumi.set(__self__, "entries", entries)
        if slots is not None:
            pulumi.set(__self__, "slots", slots)
        if transactions is not None:
            pulumi.set(__self__, "transactions", transactions)
        if transactions_status is not None:
            pulumi.set(__self__, "transactions_status", transactions_status)

    @property
    @pulumi.getter
    def accounts(self) -> Optional[pulumi.Input['GrpcConfigFilterLimitsAccountsArgs']]:
        return pulumi.get(self, "accounts")

    @accounts.setter
    def accounts(self, value: Optional[pulumi.Input['GrpcConfigFilterLimitsAccountsArgs']]):
        pulumi.set(self, "accounts", value)

    @property
    @pulumi.getter
    def blocks(self) -> Optional[pulumi.Input['GrpcConfigFilterLimitsBlocksArgs']]:
        return pulumi.get(self, "blocks")

    @blocks.setter
    def blocks(self, value: Optional[pulumi.Input['GrpcConfigFilterLimitsBlocksArgs']]):
        pulumi.set(self, "blocks", value)

    @property
    @pulumi.getter(name="blocksMeta")
    def blocks_meta(self) -> Optional[pulumi.Input['GrpcConfigFilterLimitsBlocksMetaArgs']]:
        return pulumi.get(self, "blocks_meta")

    @blocks_meta.setter
    def blocks_meta(self, value: Optional[pulumi.Input['GrpcConfigFilterLimitsBlocksMetaArgs']]):
        pulumi.set(self, "blocks_meta", value)

    @property
    @pulumi.getter
    def entries(self) -> Optional[pulumi.Input['GrpcConfigFilterLimitsEntriesArgs']]:
        return pulumi.get(self, "entries")

    @entries.setter
    def entries(self, value: Optional[pulumi.Input['GrpcConfigFilterLimitsEntriesArgs']]):
        pulumi.set(self, "entries", value)

    @property
    @pulumi.getter
    def slots(self) -> Optional[pulumi.Input['GrpcConfigFilterLimitsSlotsArgs']]:
        return pulumi.get(self, "slots")

    @slots.setter
    def slots(self, value: Optional[pulumi.Input['GrpcConfigFilterLimitsSlotsArgs']]):
        pulumi.set(self, "slots", value)

    @property
    @pulumi.getter
    def transactions(self) -> Optional[pulumi.Input['GrpcConfigFilterLimitsTransactionsArgs']]:
        return pulumi.get(self, "transactions")

    @transactions.setter
    def transactions(self, value: Optional[pulumi.Input['GrpcConfigFilterLimitsTransactionsArgs']]):
        pulumi.set(self, "transactions", value)

    @property
    @pulumi.getter(name="transactionsStatus")
    def transactions_status(self) -> Optional[pulumi.Input['GrpcConfigFilterLimitsTransactionsArgs']]:
        return pulumi.get(self, "transactions_status")

    @transactions_status.setter
    def transactions_status(self, value: Optional[pulumi.Input['GrpcConfigFilterLimitsTransactionsArgs']]):
        pulumi.set(self, "transactions_status", value)


if not MYPY:
    class GrpcConfigGrpcCompressionArgsDict(TypedDict):
        accept: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        send: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
elif False:
    GrpcConfigGrpcCompressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigGrpcCompressionArgs:
    def __init__(__self__, *,
                 accept: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 send: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        if accept is not None:
            pulumi.set(__self__, "accept", accept)
        if send is not None:
            pulumi.set(__self__, "send", send)

    @property
    @pulumi.getter
    def accept(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "accept")

    @accept.setter
    def accept(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "accept", value)

    @property
    @pulumi.getter
    def send(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        return pulumi.get(self, "send")

    @send.setter
    def send(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "send", value)


if not MYPY:
    class GrpcConfigGrpcServerTLSArgsDict(TypedDict):
        cert_path: pulumi.Input[builtins.str]
        key_path: pulumi.Input[builtins.str]
elif False:
    GrpcConfigGrpcServerTLSArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigGrpcServerTLSArgs:
    def __init__(__self__, *,
                 cert_path: pulumi.Input[builtins.str],
                 key_path: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "cert_path", cert_path)
        pulumi.set(__self__, "key_path", key_path)

    @property
    @pulumi.getter(name="certPath")
    def cert_path(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "cert_path")

    @cert_path.setter
    def cert_path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cert_path", value)

    @property
    @pulumi.getter(name="keyPath")
    def key_path(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "key_path")

    @key_path.setter
    def key_path(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "key_path", value)


if not MYPY:
    class GrpcConfigGrpcArgsDict(TypedDict):
        address: pulumi.Input[builtins.str]
        channel_capacity: NotRequired[pulumi.Input[builtins.int]]
        compression: NotRequired[pulumi.Input['GrpcConfigGrpcCompressionArgsDict']]
        filter_limits: NotRequired[pulumi.Input['GrpcConfigFilterLimitsArgsDict']]
        filter_name_size_limit: NotRequired[pulumi.Input[builtins.int]]
        filter_names_cleanup_interval: NotRequired[pulumi.Input[builtins.str]]
        filter_names_size_limit: NotRequired[pulumi.Input[builtins.int]]
        max_decoding_message_size: NotRequired[pulumi.Input[builtins.int]]
        replay_stored_slots: NotRequired[pulumi.Input[builtins.int]]
        server_http2_adaptive_window: NotRequired[pulumi.Input[builtins.bool]]
        server_http2_keepalive_interval: NotRequired[pulumi.Input[builtins.str]]
        server_http2_keepalive_timeout: NotRequired[pulumi.Input[builtins.str]]
        server_initial_connection_window_size: NotRequired[pulumi.Input[builtins.int]]
        server_initial_stream_window_size: NotRequired[pulumi.Input[builtins.int]]
        snapshot_client_channel_capacity: NotRequired[pulumi.Input[builtins.int]]
        snapshot_plugin_channel_capacity: NotRequired[pulumi.Input[builtins.int]]
        tls_config: NotRequired[pulumi.Input['GrpcConfigGrpcServerTLSArgsDict']]
        unary_concurrency_limit: NotRequired[pulumi.Input[builtins.int]]
        unary_disabled: NotRequired[pulumi.Input[builtins.bool]]
        x_token: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GrpcConfigGrpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigGrpcArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str],
                 channel_capacity: Optional[pulumi.Input[builtins.int]] = None,
                 compression: Optional[pulumi.Input['GrpcConfigGrpcCompressionArgs']] = None,
                 filter_limits: Optional[pulumi.Input['GrpcConfigFilterLimitsArgs']] = None,
                 filter_name_size_limit: Optional[pulumi.Input[builtins.int]] = None,
                 filter_names_cleanup_interval: Optional[pulumi.Input[builtins.str]] = None,
                 filter_names_size_limit: Optional[pulumi.Input[builtins.int]] = None,
                 max_decoding_message_size: Optional[pulumi.Input[builtins.int]] = None,
                 replay_stored_slots: Optional[pulumi.Input[builtins.int]] = None,
                 server_http2_adaptive_window: Optional[pulumi.Input[builtins.bool]] = None,
                 server_http2_keepalive_interval: Optional[pulumi.Input[builtins.str]] = None,
                 server_http2_keepalive_timeout: Optional[pulumi.Input[builtins.str]] = None,
                 server_initial_connection_window_size: Optional[pulumi.Input[builtins.int]] = None,
                 server_initial_stream_window_size: Optional[pulumi.Input[builtins.int]] = None,
                 snapshot_client_channel_capacity: Optional[pulumi.Input[builtins.int]] = None,
                 snapshot_plugin_channel_capacity: Optional[pulumi.Input[builtins.int]] = None,
                 tls_config: Optional[pulumi.Input['GrpcConfigGrpcServerTLSArgs']] = None,
                 unary_concurrency_limit: Optional[pulumi.Input[builtins.int]] = None,
                 unary_disabled: Optional[pulumi.Input[builtins.bool]] = None,
                 x_token: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "address", address)
        if channel_capacity is not None:
            pulumi.set(__self__, "channel_capacity", channel_capacity)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if filter_limits is not None:
            pulumi.set(__self__, "filter_limits", filter_limits)
        if filter_name_size_limit is not None:
            pulumi.set(__self__, "filter_name_size_limit", filter_name_size_limit)
        if filter_names_cleanup_interval is not None:
            pulumi.set(__self__, "filter_names_cleanup_interval", filter_names_cleanup_interval)
        if filter_names_size_limit is not None:
            pulumi.set(__self__, "filter_names_size_limit", filter_names_size_limit)
        if max_decoding_message_size is not None:
            pulumi.set(__self__, "max_decoding_message_size", max_decoding_message_size)
        if replay_stored_slots is not None:
            pulumi.set(__self__, "replay_stored_slots", replay_stored_slots)
        if server_http2_adaptive_window is not None:
            pulumi.set(__self__, "server_http2_adaptive_window", server_http2_adaptive_window)
        if server_http2_keepalive_interval is not None:
            pulumi.set(__self__, "server_http2_keepalive_interval", server_http2_keepalive_interval)
        if server_http2_keepalive_timeout is not None:
            pulumi.set(__self__, "server_http2_keepalive_timeout", server_http2_keepalive_timeout)
        if server_initial_connection_window_size is not None:
            pulumi.set(__self__, "server_initial_connection_window_size", server_initial_connection_window_size)
        if server_initial_stream_window_size is not None:
            pulumi.set(__self__, "server_initial_stream_window_size", server_initial_stream_window_size)
        if snapshot_client_channel_capacity is not None:
            pulumi.set(__self__, "snapshot_client_channel_capacity", snapshot_client_channel_capacity)
        if snapshot_plugin_channel_capacity is not None:
            pulumi.set(__self__, "snapshot_plugin_channel_capacity", snapshot_plugin_channel_capacity)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if unary_concurrency_limit is not None:
            pulumi.set(__self__, "unary_concurrency_limit", unary_concurrency_limit)
        if unary_disabled is not None:
            pulumi.set(__self__, "unary_disabled", unary_disabled)
        if x_token is not None:
            pulumi.set(__self__, "x_token", x_token)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="channelCapacity")
    def channel_capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "channel_capacity")

    @channel_capacity.setter
    def channel_capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "channel_capacity", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input['GrpcConfigGrpcCompressionArgs']]:
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input['GrpcConfigGrpcCompressionArgs']]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter(name="filterLimits")
    def filter_limits(self) -> Optional[pulumi.Input['GrpcConfigFilterLimitsArgs']]:
        return pulumi.get(self, "filter_limits")

    @filter_limits.setter
    def filter_limits(self, value: Optional[pulumi.Input['GrpcConfigFilterLimitsArgs']]):
        pulumi.set(self, "filter_limits", value)

    @property
    @pulumi.getter(name="filterNameSizeLimit")
    def filter_name_size_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "filter_name_size_limit")

    @filter_name_size_limit.setter
    def filter_name_size_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "filter_name_size_limit", value)

    @property
    @pulumi.getter(name="filterNamesCleanupInterval")
    def filter_names_cleanup_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "filter_names_cleanup_interval")

    @filter_names_cleanup_interval.setter
    def filter_names_cleanup_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "filter_names_cleanup_interval", value)

    @property
    @pulumi.getter(name="filterNamesSizeLimit")
    def filter_names_size_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "filter_names_size_limit")

    @filter_names_size_limit.setter
    def filter_names_size_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "filter_names_size_limit", value)

    @property
    @pulumi.getter(name="maxDecodingMessageSize")
    def max_decoding_message_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "max_decoding_message_size")

    @max_decoding_message_size.setter
    def max_decoding_message_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_decoding_message_size", value)

    @property
    @pulumi.getter(name="replayStoredSlots")
    def replay_stored_slots(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "replay_stored_slots")

    @replay_stored_slots.setter
    def replay_stored_slots(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "replay_stored_slots", value)

    @property
    @pulumi.getter(name="serverHttp2AdaptiveWindow")
    def server_http2_adaptive_window(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "server_http2_adaptive_window")

    @server_http2_adaptive_window.setter
    def server_http2_adaptive_window(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "server_http2_adaptive_window", value)

    @property
    @pulumi.getter(name="serverHttp2KeepaliveInterval")
    def server_http2_keepalive_interval(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "server_http2_keepalive_interval")

    @server_http2_keepalive_interval.setter
    def server_http2_keepalive_interval(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_http2_keepalive_interval", value)

    @property
    @pulumi.getter(name="serverHttp2KeepaliveTimeout")
    def server_http2_keepalive_timeout(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "server_http2_keepalive_timeout")

    @server_http2_keepalive_timeout.setter
    def server_http2_keepalive_timeout(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "server_http2_keepalive_timeout", value)

    @property
    @pulumi.getter(name="serverInitialConnectionWindowSize")
    def server_initial_connection_window_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "server_initial_connection_window_size")

    @server_initial_connection_window_size.setter
    def server_initial_connection_window_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "server_initial_connection_window_size", value)

    @property
    @pulumi.getter(name="serverInitialStreamWindowSize")
    def server_initial_stream_window_size(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "server_initial_stream_window_size")

    @server_initial_stream_window_size.setter
    def server_initial_stream_window_size(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "server_initial_stream_window_size", value)

    @property
    @pulumi.getter(name="snapshotClientChannelCapacity")
    def snapshot_client_channel_capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "snapshot_client_channel_capacity")

    @snapshot_client_channel_capacity.setter
    def snapshot_client_channel_capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "snapshot_client_channel_capacity", value)

    @property
    @pulumi.getter(name="snapshotPluginChannelCapacity")
    def snapshot_plugin_channel_capacity(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "snapshot_plugin_channel_capacity")

    @snapshot_plugin_channel_capacity.setter
    def snapshot_plugin_channel_capacity(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "snapshot_plugin_channel_capacity", value)

    @property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['GrpcConfigGrpcServerTLSArgs']]:
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['GrpcConfigGrpcServerTLSArgs']]):
        pulumi.set(self, "tls_config", value)

    @property
    @pulumi.getter(name="unaryConcurrencyLimit")
    def unary_concurrency_limit(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "unary_concurrency_limit")

    @unary_concurrency_limit.setter
    def unary_concurrency_limit(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "unary_concurrency_limit", value)

    @property
    @pulumi.getter(name="unaryDisabled")
    def unary_disabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        return pulumi.get(self, "unary_disabled")

    @unary_disabled.setter
    def unary_disabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "unary_disabled", value)

    @property
    @pulumi.getter(name="xToken")
    def x_token(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "x_token")

    @x_token.setter
    def x_token(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "x_token", value)


if not MYPY:
    class GrpcConfigLogArgsDict(TypedDict):
        level: NotRequired[pulumi.Input[builtins.str]]
elif False:
    GrpcConfigLogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigLogArgs:
    def __init__(__self__, *,
                 level: Optional[pulumi.Input[builtins.str]] = None):
        if level is not None:
            pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def level(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "level", value)


if not MYPY:
    class GrpcConfigPrometheusArgsDict(TypedDict):
        address: pulumi.Input[builtins.str]
elif False:
    GrpcConfigPrometheusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigPrometheusArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[builtins.str]):
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "address", value)


if not MYPY:
    class GrpcConfigTokioArgsDict(TypedDict):
        affinity: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        worker_threads: NotRequired[pulumi.Input[builtins.int]]
elif False:
    GrpcConfigTokioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GrpcConfigTokioArgs:
    def __init__(__self__, *,
                 affinity: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 worker_threads: Optional[pulumi.Input[builtins.int]] = None):
        if affinity is not None:
            pulumi.set(__self__, "affinity", affinity)
        if worker_threads is not None:
            pulumi.set(__self__, "worker_threads", worker_threads)

    @property
    @pulumi.getter
    def affinity(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        return pulumi.get(self, "affinity")

    @affinity.setter
    def affinity(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "affinity", value)

    @property
    @pulumi.getter(name="workerThreads")
    def worker_threads(self) -> Optional[pulumi.Input[builtins.int]]:
        return pulumi.get(self, "worker_threads")

    @worker_threads.setter
    def worker_threads(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "worker_threads", value)


if not MYPY:
    class YellowstoneGRPCArgsDict(TypedDict):
        version: pulumi.Input[builtins.str]
        config: NotRequired[pulumi.Input['ConfigArgsDict']]
        json: NotRequired[pulumi.Input[builtins.str]]
elif False:
    YellowstoneGRPCArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class YellowstoneGRPCArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[builtins.str],
                 config: Optional[pulumi.Input['ConfigArgs']] = None,
                 json: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "version", version)
        if config is not None:
            pulumi.set(__self__, "config", config)
        if json is not None:
            pulumi.set(__self__, "json", json)

    @property
    @pulumi.getter
    def version(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "version", value)

    @property
    @pulumi.getter
    def config(self) -> Optional[pulumi.Input['ConfigArgs']]:
        return pulumi.get(self, "config")

    @config.setter
    def config(self, value: Optional[pulumi.Input['ConfigArgs']]):
        pulumi.set(self, "config", value)

    @property
    @pulumi.getter
    def json(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "json")

    @json.setter
    def json(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "json", value)


